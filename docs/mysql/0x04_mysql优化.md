在高负载情况下，MySQL 性能可能会受到影响。以下是一些常见的 MySQL 性能优化技巧：

## 数据库查询优化

1.
2. 优化 SQL 语句：编写高效的 SQL 语句可以提高 MySQL 性能。使用 EXPLAIN 命令可以帮助识别 SQL 语句中的慢查询。
   1. 分页优化：延迟关联，书签方式
   2. 索引优化：覆盖索引(避免回表)，最左原则，前缀索引(邮箱，用户名等前几位)，小表驱动大表
      1. 使用索引：索引可以加速数据库查询，因此在查询常用的列时应该为它们创建索引。但是，过多的索引会影响写入性能，因此需要权衡索引的数量和性能之间的平衡。
      2. 优化查询：避免使用 SELECT \*语句，因为它会使查询变得缓慢。只选择需要的列。尽可能使用 INNER JOIN 或 LEFT JOIN，避免使用子查询。使用 WHERE 条件约束查询范围。
   3. 慢查询日志：explain 查看执行计划，关注有没有用索引，索引的类型
3. 优化缓存：使用缓存可以减少数据库查询次数，从而提高性能。MySQL 本身提供了查询缓存功能，但是在高并发环境下可能会导致性能下降。
4. 使用连接池：使用连接池可以减少连接 MySQL 的开销，从而提高性能。
5. 监控性能：定期监控 MySQL 的性能可以及时发现性能问题，并采取相应的措施。MySQL 提供了一些内置的监控工具，例如 SHOW STATUS 和 SHOW PROCESSLIST 命令。

## 数据库设计优化

1. 优化表结构：使用适当的数据类型和表结构可以提高性能。例如，使用整数类型来存储 ID，使用 CHAR 类型来存储定长字符串等。
2. 分离读写：将读写操作分离到不同的服务器上，可以提高 MySQL 的性能。读操作可以在主服务器上执行，而写操作可以在从服务器上执行。

## 配置运维

1. 优化服务器配置：调整服务器参数可以提高 MySQL 性能。例如，增加缓冲区大小、调整连接超时时间等。

2. 定期优化数据库：定期优化数据库可以清除无用数据、重建索引等操作，从而提高性能。可以使用 MySQL 自带的 OPTIMIZE TABLE 命令。

**SQL 优化**

- 分页优化：延迟关联，书签方式
- 索引优化：覆盖索引(避免回表)，最左原则，前缀索引(邮箱，用户名等前几位)，小表驱动大表
- 慢查询日志：explain 查看执行计划，关注有没有用索引，索引的类型

**库表设计优化:**

- 禁止使用 NULL
- 合适的数据类型
- 数据长度尽量小
- 分库分表策略
  **硬件扩展：**

- scale-up 垂直扩展：提高单机性能

- scale-out 横向扩展：主从，分库分表

**软件扩展：**

- 分库分表：range, hash, 基因法

## SQL 优化

### 分页优化

- 延迟关联

  先通过 where 条件提取出主键，在将该表与原数据表关联，通过主键 id 提取数据行，而不是通过原来的二级索引提取数据行

  select a.\* from table a, (select id from table where type = 2 and level = 9 order by id asc limit 190289,10 ) b where a.id = b.id

- 书签方式

  书签方式说白了就是找到 limit 第一个参数对应的主键值，再根据这个主键值再去过滤并 limit

### 索引优化

- 正确使用索引

  - 建立覆盖索引

    InnoDB 使用辅助索引查询数据时会回表，但是如果索引的叶节点中已经包含要查询的字段，那它没有必要再回表查询了，这就叫覆盖索引

    例如对于如下查询：

    select name from test where city='上海'

    我们将被查询的字段建立到联合索引中，这样查询结果就可以直接从索引中获取

    alter table test add index idx_city_name (city, name);

  - 避免在 where 查询条件中使用 != 或者 <> 操作符

    SQL 中，不等于操作符会导致查询引擎放弃索引索引，引起全表扫描，即使比较的字段上有索引

    解决方法：通过把不等于操作符改成 or，可以使用索引，避免全表扫描

    例如，把 column<>’aaa’，改成 column>’aaa’ or column<’aaa’ ，就可以使用索引了

  - 适当使用前缀索引

    MySQL 是支持前缀索引的，也就是说我们可以定义字符串的一部分来作为索引

    我们知道索引越长占用的磁盘空间就越大，那么在相同数据页中能放下的索引值也就越少，这就意味着搜索索引需要的查询时间也就越长，进而查询的效率就会降低，所以我们可以适当的选择使用前缀索引，以减少空间的占用和提高查询效率

    比如，邮箱的后缀都是固定的“@xxx.com”，那么类似这种后面几位为固定值的字段就非常适合定义为前缀索引

    alter table test add index index2(email(6));

    使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本

    需要注意的是，前缀索引也存在缺点，MySQL 无法利用前缀索引做 order by 和 group by 操作，也无法作为覆盖索引

  - 查询具体的字段而非全部字段

    要尽量避免使用 select \*，而是查询需要的字段，这样可以提升速度，以及减少网络传输的带宽压力

- 正确使用联合索引

  使用了 B+ 树的 MySQL 数据库引擎，比如 InnoDB 引擎，在每次查询复合字段时是从左往右匹配数据的，因此在创建联合索引的时候需要注意索引创建的顺序

  例如，我们创建了一个联合索引是 idx(name,age,sex)，那么当我们使用，姓名+年龄+性别、姓名+年龄、姓名等这种最左前缀查询条件时，就会触发联合索引进行查询；然而如果非最左匹配的查询条件，例如，性别+姓名这种查询条件就不会触发联合索

- 不要在列上进行运算操作

  不要在列字段上进行算术运算或其他表达式运算，否则可能会导致查询引擎无法正确使用索引，从而影响了查询的效率

  select _ from test where id + 1 = 50;
  select _ from test where month(updateTime) = 7;

### Join 优化

- 尽可能减少嵌套循环的循环次数

  一个显著优化方式是对被驱动表的 join 字段建立索引，利用索引能快速匹配到对应的行，避免与内层表每一行记录做比较，极大地减少总循环次数。另一个优化点，就是连接时用小结果集驱动大结果集，在索引优化的基础上能进一步减少嵌套循环的次数

- 避免使用 JOIN 关联太多的表

- 优化子查询

  尽量使用 Join 语句来替代子查询，因为子查询是嵌套查询，而嵌套查询会新创建一张临时表，而临时表的创建与销毁会占用一定的系统资源以及花费一定的时间，同时对于返回结果集比较大的子查询，其对查询性能的影响更大

- 小表驱动大表

  我们要尽量使用小表驱动大表的方式进行查询，也就是如果 B 表的数据小于 A 表的数据，那执行的顺序就是先查 B 表再查 A 表，具体查询语句如下：

  select name from A where id in (select id from B);

- 防止隐式类型转换

  select \* from test where skuId=123456

  skuId 这个字段上有索引，但是 explain 的结果却显示这条语句会全表扫描

  原因在于 skuId 的字符类型是 varchar(32)，比较值却是整型，故需要做类型转换

- 适当增加冗余字段

  增加冗余字段可以减少大量的连表查询，因为多张表的连表查询性能很低，所有可以适当的增加冗余字段，以减少多张表的关联查询，这是以空间换时间的优化策略

  缺点，可能造成数据不一致

### 排序优化

- 利用索引扫描做排序

  MySQL 有两种方式生成有序结果：其一是对结果集进行排序的操作，其二是按照索引顺序扫描得出的结果自然是有序的

  但是如果索引不能覆盖查询所需列，就不得不每扫描一条记录回表查询一次，这个读操作是随机 IO，通常会比顺序全表扫描还慢

  因此，在设计索引时，尽可能使用同一个索引既满足排序又用于查找行

  例如：

  --建立索引（date,staff_id,customer_id）
  select staff_id, customer_id from test where date = '2010-01-01' order by staff_id,customer_id;
  只有当索引的列顺序和 ORDER BY 子句的顺序完全一致，并且所有列的排序方向都一样时，才能够使用索引来对结果做排序

### UNION 优化

MySQL 处理 union 的策略是先创建临时表，然后将各个查询结果填充到临时表中最后再来做查询，很多优化策略在 union 查询中都会失效，因为它无法利用索引

最好手工将 where、limit 等子句下推到 union 的各个子查询中，以便优化器可以充分利用这些条件进行优化

此外，除非确实需要服务器去重，一定要使用 union all，如果不加 all 关键字，MySQL 会给临时表加上 distinct 选项，这会导致对整个临时表做唯一性检查，代价很高

### 慢查询日志

出现慢查询通常的排查手段是先使用慢查询日志功能，查询出比较慢的 SQL 语句，然后再通过 Explain 来查询 SQL 语句的执行计划，最后分析并定位出问题的根源，再进行处理

慢查询日志指的是在 MySQL 中可以通过配置来开启慢查询日志的记录功能，超过 long_query_time 值的 SQL 将会被记录在日志中

我们可以通过设置“slow_query_log=1”来开启慢查询

需要注意的是，在开启慢日志功能之后，会对 MySQL 的性能造成一定的影响，因此在生产环境中要慎用此功能

## 设计优化

### 避免使用 NULL

NULL 在 MySQL 中不好处理，存储需要额外空间，运算也需要特殊的运算符，含有 NULL 的列很难进行查询优化

应当指定列为 not null，用 0、空串或其他特殊的值代替空值，比如定义为 int not null default 0

### 最小数据长度

越小的数据类型长度通常在磁盘、内存和 CPU 缓存中都需要更少的空间，处理起来更快

### 使用最简单数据类型

简单的数据类型操作代价更低，比如：能使用 int 类型就不要使用 varchar 类型，因为 int 类型比 varchar 类型的查询效率更高

### 尽量少定义 text 类型

### 适当分表、分库策略

详细参考下面关于分库分表的概述

### 常见类型选择

- 整数类型宽度设置

  MySQL 可以为整数类型指定宽度，例如 int(11)，实际上并没有意义，它并不会限制值的范围，对于存储和计算来说，int(1)和 int(20)是相同的

- VARCHAR 和 CHAR 类型

  char 类型是定长的，而 varchar 存储可变字符串，比定长更省空间，但是 varchar 需要额外 1 或 2 个字节记录字符串长度，更新时也容易产生碎片

  需要结合使用场景来选择：如果字符串列最大长度比平均长度大很多，或者列的更新很少，选择 varchar 较合适；如果要存很短的字符串，或者字符串值长度都相同，比如 MD5 值，或者列数据经常变更，选择使用 char 类型

- DATETIME 和 TIMESTAMP 类型
  datetime 的范围更大，能表示从 1001 到 9999 年，timestamp 只能表示从 1970 年到 2038 年。datetime 与时区无关，timestamp 显示值依赖于时区。在大多数场景下，这两种类型都能良好地工作，但是建议使用 timestamp，因为 datetime 占用 8 个字节，timestamp 只占用了 4 个字节，timestamp 空间效率更高
- BLOB 和 TEXT 类型

  blob 和 text 都是为存储很大数据而设计的字符串数据类型，分别采用二进制和字符方式存储

  在实际使用中，要慎用这两种类型，它们的查询效率很低，如果字段必须要使用这两种类型，可以把此字段分离成子表，需要查询此字段时使用联合查询，这样可以提高主表的查询效率

### 范式化

当数据较好范式化时，修改的数据更少，而且范式化的表通常要小，可以有更多的数据缓存在内存中，所以执行操作会更快

缺点则是查询时需要更多的关联

- 第一范式

  字段不可分割，数据库默认支持

- 第二范式

  消除对主键的部分依赖，可以在表中加上一个与业务逻辑无关的字段作为主键，比如用自增 id

- 第三范式

  消除对主键的传递依赖，可以将表拆分，减少数据冗余

## 高扩展（硬件优化）

### scale-up

向上扩展或者纵向扩展，主要是提供比现在服务器更好性能的服务器，比如增加 CPU 和内存以及磁盘阵列等

- 磁盘

  磁盘应该尽量使用有高性能读写能力的磁盘，比如固态硬盘，这样就可以减少 I/O 运行的时间，从而提高了 MySQL 整体的运行效率

  磁盘也可以尽量使用多个小磁盘而不是一个大磁盘，因为磁盘的转速是固定的，有多个小磁盘就相当于拥有多个并行运行的磁盘一样

- 网络

  保证网络带宽的通畅（低延迟）以及够大的网络带宽是 MySQL 正常运行的基本条件，如果条件允许的话也可以设置多个网卡，以提高网络高峰期 MySQL 服务器的运行效率

- 内存

  MySQL 服务器的内存越大，那么存储和缓存的信息也就越多，而内存的性能是非常高的，从而提高了整个 MySQL 的运行效率

### scale-out

向外扩展或者横向扩展，是指增加服务器数量的扩展，这样主要能分散各个服务器的压力

- 主从

## 分库分表

### 问题

- 用户请求量太大

  单服务器 TPS、内存、IO 都是有上限的，需要将请求打散分布到多个服务器

- 单库数据量太大

  单个数据库处理能力有限；单库所在服务器的磁盘空间有限；单库上的操作 IO 有瓶颈

- 单表数据量太大

  查询、插入、更新操作都会变慢，在加字段、加索引、机器迁移都会产生高负载，影响服务

### 垂直拆分 scale-up

- 垂直分库

  微服务架构时，业务切割得足够独立，数据也会按照业务切分，保证业务数据隔离，大大提 升了数据库的吞吐能力

- 垂直分表

  表中字段太多 或者 包含大字段的时候，建议垂直分表；

  单行数据过大产生问题：在查询时对数据库的 IO、内存会受到影响，同时更新数据时，产生的 binlog 文件会很大，MySQL 在主从同步时也会有延迟的风险

  实际场景：用户表，一般会拆分为用户基础信息，用户鉴权信息，用户业务信息几张子表

### 水平拆分 scale-out

- 水平分库

  将单张表的数据切分到多个服务器上去，每个服务器具有相应的库与表，只是表中数据集合 不同。 水平分库分表能够有效的缓解单机和单库的性能瓶颈和压力，突破 IO、连接数、硬件 资源等的瓶颈

  水平分库规则

  不跨库、不跨表，保证同一类的数据都在同一个服务器上面。 数据在切分之前，需要考虑如何高效的进行数据获取，如果每次查询都要跨越多个节点，就需要谨 慎使用。

- 水平分表

  针对数据量巨大的单张表（比如订单表），按照规则把一张表的数据切分到多张表里面去。 但是这些表还是在同一个库中，所以库级别的数据库操作还是有 IO 瓶颈

  - 水平分表规则

    - RANGE

      时间：按照年、月、日去切分。例如 order_2020、order_202005、order_20200501
      地域：按照省或市去切分。例如 order_beijing、order_shanghai、order_chengdu
      大小：从 0 到 1000000 一个表。例如 1000001-2000000 放一个表，每 100 万放一个表

    - HASH

      根据用户 ID 取模，不同的业务使用的切分规则是不一样，就上面提到的切分规则，举例如下：

      站内信
      用户维度：用户只能看到发送给自己的消息，其他用户是不可见的，这种情况下是按照 用户 ID hash 分库，在用户查看历史记录翻页查询时，所有的查询请求都在同一个库内
      用户表

      范围法：以用户 ID 为划分依据，将数据水平切分到两个数据库实例，如：1 到 1000W 在一张表，1000W 到 2000W 在一张表，这种情况会出现单表的负载较高

      按照用户 ID HASH 尽量保证用户数据均衡分到数据库中
      如果在登录场景下，用户输入手机号和验证码进行登录，这种情况下，登录时是不是需要扫描所有分库的信息？ 最终方案：用户信息采用 ID 做切分处理，同时存储用户 ID 和手机号的映射的关系表（新增一个关系表），关系表采用手机号进行切分。可以通过关系表根据手机号查询到对应的 ID，再定位用户信息。

### 技术方案

- sharding-jdbc
- MyCat
