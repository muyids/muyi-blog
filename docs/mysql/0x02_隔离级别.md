- 事务
- 隔离级别
- 脏读、不可重复读、幻读这些问题 如何解决？
-

## 事务

### ACID 属性

- 原子性（atomicity)

  - 要么全部成功，要么全部失败，不可能只执行一部分操作

- 一致性（consistency)

  - 系统(数据库)总是从一个一致性的状态转移到另一个一致性的状态，不会存在中间状态

- 隔离性（isolation） - 4 个隔离级别

  - 通常来说：一个事务在完全提交之前，对其他事务是不可见的。也有例外情况

- 持久性（durability）

  - 一旦事务提交，那么就永远是这样子了，哪怕系统崩溃也不会影响到这个事务的结果

转账业务：A 给 B 转账 1000 元看作一个事务，账户 A 要 -1000，账户 B 要 + 1000；

对于同一时刻仅有一个事务处理的场景（串行化），上面业务不会发生问题；

但是，如果存在多事务并发的情况，会引发一些问题，如：脏读、不可重复读、幻读。

## 隔离级别

本质（目的）：隔离级别是为了 控制读取数据的时机。

## 脏读、不可重复读、幻读这些问题 如何解决？

这些问题都是因为 多事务的并发进行造成的。

先明确 这几个问题是什么：

- 脏读：A 事务读取到了 B 事务**_未提交_**的内容，而 B 事务后面进行了回滚
- 不可重复读：当设置 A 事务只能读取 B 事务已经提交的部分，会造成在 A 事务内的两次查询，结果竟然不一样，因为在此期间 B 事务进行了提交操作
- 幻读：**仅专指“新插入的行”**；A 事务读取了一个范围的内容，而同时 B 事务在此期间插入了一条数据，然后 A 又发现了 B 新插入的数据，造成"幻觉"

两种解决方案：

1. 读操作利用 MVCC ，写操作进行加锁
   1. 读操作：只能读到 生成 ReadView 之前提交的事务所做的更改；生成 ReadView 之前未提交的事务 或 之后才开启的事务所做的 更改是看不到的。
   2. 写操作：针对的是 最新版本的记录；读操作针对的历史版本和改动记录针对的最新版本并不冲突，所以 采用 MVCC 时，读写不冲突
2. 读、写操作都 加锁
   1. 读写操作：某些业务场景不允许读取记录的旧版本，比如 银行存款业务

不同隔离级别下的 MVCC：（生成 ReadView 的时间不一样）

- 在 READ COMMITTED 隔离级别下，一个事务在执行过程中**每次执行 SELECT 操作**时都会生成一个 ReadView，ReadView 的存在本身就保证了事务不可以读取到未提交的事务所做的更改，也就是避免了脏读现象；
- REPEATABLE READ 隔离级别下，一个事务在执行过程中**只有第一次执行 SELECT 操作**才会生成一个 ReadView，之后的 SELECT 操作都复用这个 ReadView，这样也就避免了不可重复读的问题
