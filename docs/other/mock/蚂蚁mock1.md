## 用到分布式事务嘛?为什么用这种方案,有其他方案嘛?

CAP

BASE

分布式事务的几种解决方案

- **2PC(二阶段提交)方案**，事务的提交分为两个阶段：准备阶段和提交执行方案。
- **TCC（即 Try、Confirm、Cancel）**，它采用了补偿机制，核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。
- **本地消息表**，它的核心思想就是将分布式事务拆分成本地事务进行处理。
- **最大努力通知**，实现最大努力通知，可以采用 MQ 的 ack 机制。
- **Saga 事务**，它的核心思想是将长事务拆分为多个本地短事务，由 Saga 事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。

本地消息表最常用

- 消息发送方

- 消息消费方

## JDK6、7、8 分别提供了哪些新特性

jdk8

- lambada 表达式
- 函数式接口
- Optional

##

## https 原理，工作流程

## 讲讲 java jmm volatile 的实现原理

volatile

- Java 虚拟机提供的的**最轻量级的同步机制**
- 保证变量对所有线程可见性
- 禁止指令重排
- 不保证原子性

## 讲一讲 7 层网络模型，tcp 的为什么要三次握手

## 说说线程池的工作原理

![img](https://muyids.oss-cn-beijing.aliyuncs.com/b94a9789629847b28c8d001789fc6edb~tplv-k3u1fbpfcp-watermark.awebp)

## 你们数据库的高可用是怎么实现的?

- 主从半同步复制
- 高可用架构优化
  - 引入 zookeeper 做集群管理
- 共享存储
  - **DRBD 磁盘复制**
- 分布式协议
  - **MySQL cluster**

## 读写分离的场景下,怎么保证从数据库读到最新的数据?

在高并发场景或者网络不佳的场景，如果存在较大的主从同步数据延迟，这时候读请求去读从库，就会读到旧数据。

解决方案：

- 强制读主库
- 缓存标记法
  - 写请求，设置缓存标记，过期时间为 主从同步延迟时间
  - 读请求，检查缓存标记，存在，走主库；不存在，走从库

## 如何保证 MySQL 数据不丢？

- 日志先行策略（Write-Ahead Logging），只要**binlog 和 redo log**日志能保证持久化到磁盘，我们就能确保 MySQL 异常重启后，数据不丢失。
- binlog 日志，记录数据库执行更改的所有操作
- redo log，又称为**重做日志文件**，只记录事务对数据页做了哪些修改，它记录的是数据修改之后的值。

## 高并发下如何设计秒杀系统？

- 页面静态化
- 按钮至灰控制
- 服务单一职责
  - 比如秒杀的数据库、服务器是单独的
  - 秒杀服务挂了也不影响其他服务
- ## 秒杀链接加盐
- 限流
- 分布式锁
