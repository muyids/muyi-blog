## 分组背包问题

每组物品有若干，同组内的物品只能选一个

- 有 N 组物品和一个容量是 V 的背包。
- 每组物品有若干个，同一组内的物品最多只能选一个。
- 每件物品的体积是 $v_{ij}$，价值是 wij，其中 i 是组号，j 是组内编号。
- 求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。
- 输出最大价值。

```cpp
输入格式
第一行有两个整数 N，V，用空格隔开，分别表示物品组数和背包容量。

接下来有 N 组数据：

每组数据第一行有一个整数 Si，表示第 i 个物品组的物品数量；
每组数据接下来有 Si 行，每行有两个整数 vij,wij，用空格隔开，分别表示第 i 个物品组的第 j 个物品的体积和价值；
输出格式
输出一个整数，表示最大价值。
```

### 算法思路

$f[i,j]$ 只从前 i 组物品中选，且总体积不大于 j 的所有做法

对于第 i 组，不选，选第 1 个物品，选第 2 个物品，…, 选第 k 个物品

枚举第 k 个：$f[i,j] = max(f[i][j], f[i-1][j-v[i][k]] + w[i][k])$

用的是上层状态则从大到小枚举，用的是本层状态则从小到大枚举

### 代码实现

```cpp
// 当没有思路时，回到最初的步骤去思考应该如何做
// f[i,j] 只从前i组物品中选，且总体积不大于j的所有选法的最大值
// f[i,j] 最多选一个，那么可以不选，选a, 选b, 选c, 等等
// f[i,j] = max(f[i-1,j], f[i-1,j-v[k]]+w[k]) 上层从大到小枚举

#include <iostream>
#include <algorithm>
using namespace std;
const int N = 110;
int n, m;
int v[N][N], w[N][N], s[N];
int f[N];

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i ++) {
        cin >> s[i]; //
        for (int j = 0; j < s[i]; j ++)
            cin >> v[i][j] >> w[i][j];
    }

    for (int i = 1; i <= n; i ++) // 枚举物品
        for (int j = m; j >= 0; j --) // 枚举体积
            for (int k = 0; k < s[i]; k ++) // 枚举第k组
                if (j >= v[i][k]) // 务必使其有意义；第i组第k个物品
                    f[j] = max(f[j], f[j - v[i][k]] + w[i][k]);

    cout << f[m] << endl;
    return 0;
}
```
