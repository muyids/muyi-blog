观看笔记

https://www.bilibili.com/video/BV1F64y1B7sV

#### 内存模型

![2021-11-08 pm5.08.52](https://muyids.oss-cn-beijing.aliyuncs.com/2021-11-08 pm5.08.52.png)

#### **硬件内存模型**

cpu 寄存器 -> L1/L2/L3 级缓存 -> 主存

cpu 由单核发展成多核，会存在多个 cpu 同时修改内存中的数据，导致 cpu 中的缓存出现不一致的问题

![2021-11-08 pm3.54.46](https://muyids.oss-cn-beijing.aliyuncs.com/2021-11-08 pm3.54.46.png)

#### **缓存一致性协议**

CPU 缓存一致性协议，大致分为两类：

- 窥探型
- 基于目录型
  当 cpu 缓存想要访问主存时，需要经过一致性协议这种**软件层面**的措施，来保证数据的一致性；

（协议本事的实现细节这里不再发散的去展开，自行搜索：）

协议的内容一定是和数据同步相关的操作，既然是数据同步很可能出现 **等待、唤醒**等操作，会出现性能问题，尤其是对 cpu 这种运算速度极快的组件来说，丝毫的等待都是极大的浪费。

#### **指令重排序**

于是计算机科学家对 cpu 的读写做了一定的优化，主要就是把同步改为了异步，比如 cpuA 改写数据 D，cpuB 读取 D，发现正在被 cpuA 改写，就注册一个事件，然后 cpuB 去做其他的事情，数据 D 改写完毕后，响应消息，cpuB 继续处理；

但是改为异步模型，对 cpuB 来说，指令看上去就不是顺序执行的了，这时就需要**指令重排序**，保证指令集执行的结果是一致的

#### **java 内存模型**

硬件内存模型的目标是为了让汇编代码能运行在一个具有**一致性的内存视图**上；

随着高级语言的流行，工程师们开始设计编程语言级别的内存模型，这是为了让大家在使用高级语言时，也能具有一个具有一致性的内存视图；比如 java 内存模型；可以屏蔽各种硬件和操作系统的内存访问差异；

![2021-11-08 pm4.12.08](https://muyids.oss-cn-beijing.aliyuncs.com/2021-11-08 pm4.12.08.png)

具体一点，就是 把工作线程和本地内存具象为 thread stack，把主存具象为 heap。

thread stack 中的两种类型变量： 原始类型变量（比如 int，char 等）总是存储在线程栈上；对象类型的变量，引用存储在线程栈上，引用指向的对象存储在 heap 上；

heap 作为全局共享空间；存储对象本身，并不关心哪个线程正在访问对象；

我们可以这样理解，java 线程模型中的 thread stack 和 heap 都是对物理内存的一种抽象；这样开发者只需要关心自己的程序使用了 thread stack 和 heap 而不需要关心更下层的寄存器，cpu 缓存，主存等等；

![2021-11-08 pm3.35.10](https://muyids.oss-cn-beijing.aliyuncs.com/2021-11-08 pm3.35.10-6359951.png)

**（1）JVM 内存模型将内存分为 5 个区：**

栈区（java 虚拟机栈），堆区

本地方法栈，程序计数器，方法区（元空间）

**（2）各个区各自的作用：**

d. Java 虚拟机栈：用于存储局部变量，对象地址
e.堆：对象实例
a. 本地方法栈：存放 C++的 native 方法的栈区
b. 程序计数器：记录各个线程执行的字节码的行号
c. 元数据区（方法区）：类加载器 class loader 信息、常量、静态变量

**（3）线程私有、公有**

a.线程私有：每个线程在开辟、运行的过程中会单独创建这样的一份内存，有多少个线程可能有多少个内存

**Java 虚拟机栈、本地方法栈、程序计数器是线程私有的**

b.线程全局共享的

堆和方法区

**（4）GC**

栈虽然方法运行完毕了之后被清空了，但是堆上面的还没有被清空，所以引出了 GC（垃圾回收），不能立马删除，因为不知道是否还有其它的也是引用了当前的地址来访问的

#### **线程通信**

通过八个 内存读写指令，线程 A 将数据写入主存，线程 B 从主存中读取数据，实现线程中的通信

#### 线程通信存在的问题

可见性：一个线程修改变量时，其他线程能够立刻得知修改；线程 A 写入了数据 d，线程 B 需要能够接收到数据 d 的修改

原子性：要么成功，要么失败；单指令原子性；多指令原子性；

有序性：指令重排序：单线程模型中，无论指令如何重排，都能保证和顺序执行的结果是一致的

#### volatile 关键字

可见性：主动请求主存

禁止指令重排序:

#### Happens-Before 原则

对于两个操作 A 和 B，在不同线程中执行，如果 A Happens-Before B（A 先于 B 执行）；可以保证 A 执行完毕后，执行结果对 B 是可见的

规则：

1. 程序顺序规则
2. 锁定规则
3. volatile 变量规则
4. ...
