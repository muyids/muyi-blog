回收算法是内存回收的方法论，

垃圾收集器是内存回收的具体实现

#### 作用于不同分代的 7 种收集器

![2021-11-09 pm12.54.19](https://muyids.oss-cn-beijing.aliyuncs.com/2021-11-09 pm12.54.19.png)

存在连线，说明可以搭配使用

**serial 收集器**

- 单线程收集器

- stop the world
- 新生代复制算法，老年代 serial old 版本
  **parNew 收集器**

serial 收集器的多线程版本

**Parallel Scavenge 收集器**

server 模式下的默认收集器

新生代复制算法，老年代采用标记整理算法

特别之处：

**吞吐量**： = 运行用户代码时间 / (运行用户代码时间 + 垃圾回收时间)

高效率的利用 cpu;

Parallel old 是其老年代版本

## **CMS 收集器**

CMS ( concurrent mark sweep)

**以获取最短回收停顿时间为目标**

HotSpot 虚拟机 第一款真正意义上的**并发收集器**

从名字 Mark sweep 可以看出，cms 是一款标记清除算法实现的垃圾收集器

**运作过程**

1、初始标记

2、并发标记

3、重新标记

4、并发清理

优点：并发收集、低停顿

缺点：

1、cpu 资源敏感（并发）

2、无法处理浮动垃圾

3、标记-清除 会有大量内存碎片

## G1 收集器

G1 (Garbage-First)

一款面向服务器的垃圾收集器

主要针对

- 配置多核处理器和大容量内存的机器
- 以及高概率满足 GC 停顿时间要求的同时，还具备高吞吐量性能特征
  **基本特性**

1、G1 将堆划分为 2048 个大小相等的 region

2、保留了年轻代和老年代的概念，但不再是物理隔离，而是逻辑上的集合

3、region 的功能区域会动态变化

4、默认年轻代占比 5%

**G1 对大对象的处理**

1、专门分配大对象的 region 叫 Humongous

2、大对象判断规则：一个对象超过了一个 region 大小的 50%

**收集过程**

1、初始标记（STW）: 暂停所有其他线程，标记 GC Roots 直接引用的对象

2、并发标记：用一个闭包结构去记录可达对象

3、最终标记（STW）: 修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录

4、筛选回收：根据用户希望的 GC 停顿时间制定回收计划

### 与 CMS 的对比

1、region 的设计思想

2、G1 不会产生过多的空间碎片

3、stop the world 更可控，在停顿时间上添加了预测机制，用户可以指定期望停顿时间
