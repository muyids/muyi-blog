## **JVM 问题如何排查?**

### 已经发生`OOM（out of memory）`，排查步骤

#### 1. 查看当前进程信息，如 使用 arthas，linux 等系统命令如 top，free 等

arthas 是一款 生产环境在线调优、分析、诊断工具

#### 2. 生成 dump 文件

⼀般⽣产系统中都会设置当系统发⽣了 OOM 时，⽣成当时的 dump ⽂件

生产系统 提前配置 jvm 参数，参考如下：

```
-XX:+PrintGCDetails
-XX:+UseConcMarkSweepGC
-Xmx20m
-Xms20m
-XX:+HeapDumpOnOutOfMemoryError (最重要)
-XX:+HeapDumpBeforeFullGC
-XX:+HeapDumpAfterFullGC
-XX:HeapDumpPath=/tmp/gc
```

也可以使用 arthas 直接生成

#### 3. 利用 MAT 工具对 dump 日志进行分析

分析思路或方法论：

1. 定位 占用内存过大的对象 - MAT 中使用 histogram（直方图）倒序查看占用内存较高的对象
2. 这个对象被谁引用 - MAT 中使用 dominator tree（支配节点树）分析对象的调用链
3. 定位到具体代码 - MAT 中的 thread_overview(线程简介图)，里面有方法的调用链信息和堆栈信息。

### 正常运行的系统（频繁 FullGC 的情况下如何 JVM 调优）

- 可以使⽤`jmap`来查看 JVM 中各个区域的使⽤情况
- 可以通过`jstack`来查看线程的运⾏情况，⽐如哪些线程阻塞、 是否出现了死锁
- 可以通过`jstat`命令来查看垃圾回收的情况，特别是 fullgc，如果发现 fullgc ⽐较频繁，那么就得进⾏调优了
- 通过各个命令的结果，或者`jvisualvm`等⼯具来进⾏分析
- ⾸先，初步猜测频繁发送`fullgc`的原因，如果频繁发⽣ fullgc 但是⼜⼀直没有出现内存溢出，那么表示 fullgc 实际上是回收了很多对象了，所以这些对象最好能在 younggc 过程中就直接回收掉，避免这些对 象进⼊到⽼年代，对于这种情况，就要考虑这些存活时间不⻓的对象是不是⽐较⼤，导致年轻代放不 下，直接进⼊到了⽼年代，尝试加⼤年轻代的⼤⼩，如果改完之后，fullgc 减少，则证明修改有效
- 同时，还可以找到占⽤`CPU最多的线程`，定位到具体的⽅法，优化这个⽅法的执⾏，看是否能避免某些 对象的创建，从⽽节省内存

## **OOM 出现的原因**

OOM 发生在堆区、元数据区、栈

- 开发人员自身代码出现 OOM 一般有如下几种情况：

  - 请求链接阻塞超时

  - 内存泄露；连接没有释放; oss, 数据库，http 请求

  - 超大对象：缓存对象 大 map

  - 超预期的流量：通常是上游系统请求流量飙升，常见于各类促销/秒杀活动，可以结合业务流量指标排查是否有尖状峰值。

- 第三方中间件引入：
  - 比如 当请求过来时， Tomcat 每个线程会创建 两个 4M 大小的缓冲区，高并发场景会 OOM

## **OOM 这类生产问题的解决思路**

### 通用生产问题解决思路

**发生前：**做好监控，及时发现问题

**出问题**：尽快恢复，避免对用户产生印象

**复盘：**今后如何避免

1.发生事故不能慌、稳定、沉着、冷静、

2.作为领导不要责怪任何人
