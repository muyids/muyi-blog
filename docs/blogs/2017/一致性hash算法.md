---
title: 一致性哈希算法
date: 2017-10-22T00:00:00+08:00
categories: [数据结构, 算法]
tags: [数据结构, 算法]
---

`一致性哈希`常用来解决`单点的不稳定性问题`

<!--more-->

## 算法原理

先构造一个长度为 232 的整数环（这个环被称为一致性 Hash 环），根据节点名称的 Hash 值（其分布为[0, 232-1]）将服务器节点放置在这个 Hash 环上，
然后根据数据的 Key 值计算得到其 Hash 值（其分布也为[0, 232-1]），
接着在 Hash 环上顺时针查找距离这个 Key 值的 Hash 值最近的服务器节点，完成 Key 到服务器的映射查找。

这种算法解决了普通余数 Hash 算法伸缩性差的问题，可以保证在上线、下线服务器的情况下尽量有多的请求命中原来路由到的服务器。

一致性 Hash 算法比普通的余数 Hash 算法更具有伸缩性，但是同时其算法实现也更为复杂。

## 数据结构的选取

一致性 Hash 算法最先要考虑的一个问题是：构造出一个长度为 232 的整数环，根据节点名称的 Hash 值将服务器节点放置在这个 Hash 环上。

那么，整数环应该使用何种数据结构，才能使得运行时的时间复杂度最低？

首先说明一点，关于时间复杂度，常见的时间复杂度与时间效率的关系有如下的经验规则：

```
O(1) < O(log2N) < O(n) < O(N * log2N) < O(N2) < O(N3) < 2N < 3N < N!
```

一般来说，前四个效率比较高，中间两个差强人意，后三个比较差（只要 N 比较大，这个算法就动不了了）。
OK，继续前面的话题，应该如何选取数据结构，我认为有以下几种可行的解决方案。

### 解决方案一：排序+List

我想到的第一种思路是：算出所有待加入数据结构的节点名称的 Hash 值放入一个数组中，然后使用某种排序算法将其从小到大进行排序，
最后将排序后的数据放入 List 中，采用 List 而不是数组是为了结点的扩展考虑。
之后，待路由的结点，只需要在 List 中找到第一个 Hash 值比它大的服务器节点就可以了，
比如服务器节点的 Hash 值是`[0,2,4,6,8,10]`，带路由的结点是 7，只需要找到第一个比 7 大的整数，也就是 8，就是我们最终需要路由过去的服务器节点。
如果暂时不考虑前面的排序，那么这种解决方案的时间复杂度：

（1）最好的情况是第一次就找到，时间复杂度为 O(1)

（2）最坏的情况是最后一次才找到，时间复杂度为 O(N)

平均下来时间复杂度为 O(0.5N+0.5)，忽略首项系数和常数，时间复杂度为 O(N)。

但是如果考虑到之前排序算法的时间复杂度：

![各种常用排序算法](/image/sort-o.png)

看得出来，排序算法要么稳定但是时间复杂度高、要么时间复杂度低但不稳定，最好的时间复杂度仍然有 O(N\*logN)

### 解决方案二：遍历+List

既然排序操作比较耗性能，那么能不能不排序？可以的，所以进一步的，有了第二种解决方案。

解决方案使用 List 不变，不过可以采用遍历的方式：

（1）服务器节点不排序，其 Hash 值全部直接放入一个 List 中

（2）带路由的节点，算出其 Hash 值，由于指明了”顺时针”，因此遍历 List，比待路由的节点 Hash 值大的算出差值并记录，比待路由节点 Hash 值小的忽略

（3）算出所有的差值之后，最小的那个，就是最终需要路由过去的节点

在这个算法中，看一下时间复杂度：

1、最好情况是只有一个服务器节点的 Hash 值大于带路由结点的 Hash 值，其时间复杂度是 O(N)+O(1)=O(N+1)，忽略常数项，即 O(N)

2、最坏情况是所有服务器节点的 Hash 值都大于带路由结点的 Hash 值，其时间复杂度是 O(N)+O(N)=O(2N)，忽略首项系数，即 O(N)

所以，总的时间复杂度就是 O(N)。其实算法还能更改进一些：给一个位置变量 X，如果新的差值比原差值小，X 替换为新的位置，否则 X 不变。这样遍历就减少了一轮，不过经过改进后的算法时间复杂度仍为 O(N)。

总而言之，这个解决方案和解决方案一相比，总体来看，似乎更好了一些。

### 解决方案三：二叉查找树

抛开 List 这种数据结构，另一种数据结构则是使用二叉查找树。

当然我们不能简单地使用二叉查找树，因为可能出现不平衡的情况。平衡二叉查找树有 AVL 树、红黑树等，这里使用红黑树，选用红黑树的原因有两点：

1、红黑树主要的作用是用于存储有序的数据，这其实和第一种解决方案的思路又不谋而合了，但是它的效率非常高

2、JDK 里面提供了红黑树的代码实现 TreeMap 和 TreeSet

另外，以 TreeMap 为例，TreeMap 本身提供了一个 tailMap(K fromKey)方法，支持从红黑树中查找比 fromKey 大的值的集合，但并不需要遍历整个数据结构。

使用红黑树，可以使得查找的时间复杂度降低为 O(logN)，比上面两种解决方案，效率大大提升。

红黑树的数据结构决定了任何一个大于 N 的最小数据，它都只需要几次至几十次查找就可以查到。

当然，明确一点，有利必有弊，根据我另外一次测试得到的结论是，为了维护红黑树，数据插入效率 TreeMap 在三种数据结构里面是最差的，且插入要慢上 5~10 倍。

## 应用

- 数据分片
- memcache
