## Redis 持久化和主从复制原理

3 种持久化方式： RDB、AOF、混合持久化

### RDB

- Redis 将内存数据库快照保存在名字为 dump.rdb 的二进制文件
- 快照生成规则

  - N 秒内数据集至少有 M 个改动 （设置 `save 60 1000` 会让 Redis 在满足" 60 秒内有至少有 1000 个键被改动 " ）
  - 手动执行命令生成：客户端执行命令 save 或 bgsave 可以生成 dump.rdb 文件 - save 是同步命令，bgsave 是异步命令 - Redis 默认是使用的 bgsave
    优点：

- 可以恢复到之前某一时间点的数据
- 恢复速度快
  缺点：

- 数据丢失多
- save 保存快照，如果文件很大，阻塞时间长

### AOF

- 通过修改配置文件来打开 AOF 功能：`appendonly yes`

- 将修改的每一条指令记录进文件 appendonly.aof 中

- 配置 fsync 规则（三个选项）

  - appendfsync always：每次有新命令追加到 AOF 文件时就执行一次 fsync ，非常慢，也非常安全
  - appendfsync everysec：每秒 fsync 一次，在故障时只会丢失 1 秒钟的数据。
  - appendfsync no：redis 不会主动调用 fsync 去将 AOF 日志内容同步到磁盘， 完全依赖于操作系统来处理。更快，也更不安全的选择

  推荐（并且也是默认）的措施为每秒 fsync 一次， 这种 fsync 策略可以兼顾速度和安全性。

优点：

- 写入性能好，文件也不容易破损。
- **适合做灾难性数据误删除的紧急恢复**；AOF 的日志是通过一个叫非常可读的方式记录的，这样的特性就适合做灾难性数据误删除的紧急恢复了，比如公司的实习生通过 flushall 清空了所有的数据，只要这个时候 **后台重写还没发生**，你马上拷贝一份 AOF 日志文件，把最后一条 flushall 命令删了就完事了。
  缺点：

- 文件大

### 混合持久化（加强版的 AOF）

- 重启 Redis 时，很少使用 RDB 来恢复数据，因为会丢失大量数据
- 通常使用 AOF 日志重放，但是重放 AOF 日志性能较差，为了解决这个问题，redis 引入了混合持久化
- 开启混合持久化 `aof-use-rdb-preamble yes`
- 开启了混合持久化，AOF 在重写时，不再是单纯将内存数据转换为 RESP 命令写入 AOF 文件
- 而是将重写这一刻之前的内存做 RDB 快照处理，并且将 RDB 快照内容和增量的 AOF 修改内存数据的命令存在一起，写入新的 AOF 文件
- 新的 `appendonly.aof` 文件 由 **RDB 快照 + 增量的 AOF 修改** 组成
