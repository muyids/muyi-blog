### ES6 的新特性

- 类的支持：语法糖，只是让类更加直观；基于 ES5 的原型链都可以实现；
- 模块化
  - export 和 import 命令；
  - ES6 之前是整体加载一个模块；ES6 模块是编译时加载，使得静态分析成为可能; 进一步可以引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。
- 箭头函数
- 块作用域
- 字符串模板
  - 使字符串拼接，多行字符串，变量嵌入更容易书写；
- 变量的解构赋值
- 参数默认值/不定参数/拓展参数
  - 好处：**方便参数扩展**
- for-of 遍历
- generator
- Map/Set
- Promise
- Symbol: 每个 Symbol 实例都是唯一的，从根本上防止属性名的冲突；类似于 java 中的

### 谈谈个人对 ES6 的看法

- ES6 很好，更友好的语法糖，开发效率得以提高；
- 但是回归本质，不管 ES 几，还是那个 js，特性只是特性，我们搞技术最重要的 还是看清事物本质

### 箭头函数

- 函数体内的 this 对象，就是**定义时所在的对象，而不是使用时所在的对象**。
- 不可以当作构造函数
- 不可以使用 arguments 对象，该对象在函数体内不存在
- 不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。

### 块作用域

- **不存在变量提升**；不存在先使用后声明的情况
- **暂时性死区**；变量绑定在当前作用域，不受外部影响；
- **不允许重复声明**；同一作用域不能声明同名变量

### 变量的解构赋值

解构是 ES6 提供的**语法糖**，其实内在是针对**可迭代对象的 Iterator 接口**，通过遍历器按顺序获取对应的值进行赋值

只要某种数据结构具有 **Iterator 接口**，都可以采用数组形式的解构赋值。

支持 **Iterator 接口**数据结构：

1. 数组
2. Map，Set
3. Generator 函数

注意：

**对象`没有`部署 iterator 接口**:只有成员具有顺序性的 线性结构 才会部署 iterator 接口，当然也可以手动部署

### 修饰器

Decorator（注解）

- 装饰器（Decorator）是一种与类（class）相关的语法，用来**注释或修改类和类方法**。
- 装饰器对类的行为的改变，是**代码编译时发生**的，而不是在运行时。这意味着，**装饰器能在编译阶段运行代码**。也就是说，装饰器本质就是编译时执行的函数。
- 通过对目标类的**prototype**对象操作，修改类
- 装饰器不仅可以**装饰类**，还可以**装饰类的属性**。
- 如果同一个方法有多个装饰器，会像剥洋葱一样，先**从外到内进入，然后由内向外执行**
- 装饰器只能用于类和类的方法，**不能用于函数**，因为**存在函数提升**
